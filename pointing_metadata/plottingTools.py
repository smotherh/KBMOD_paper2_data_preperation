import numpy as np
from astropy.io import fits
import matplotlib.pyplot as plt
import pandas as pd
import os

def makeStamps(name,objectList,imagePath,imagePlane='science',numCols=5,
               stampSize=[31,31],timeFile='/astro/store/epyc/users/smotherh/DECAM_Data_Reduction/loriallen_times.dat'):
    """Generate postage stamps of an MPC object in the Lori Allen Dataset.
    
    INPUT-
        name: This is the name of the object for which to find the image.
            Names come from the query_MPC notebook that pulls data down from
            the Minor Planets Center.

        objectList: A pandas dataframe as generated by query_MPC.

        imagePath: The path to the stack of images from which to make stamps.

        numCols: The number of columns in the postage stamp subplot.

        imagePlane : From which plane of the fits file should the stamps be
            made? Acceptable options:
            'science' : The science image plane
            'mask' : The mask image plane
            'variance' : The varience image plane
    """
    # Set the plane number used for loading the data from a fits file
    if imagePlane == 'science':
        imagePlaneNum = 1
    elif imagePlane == 'mask':
        imagePlaneNum = 2
    elif imagePlane == 'variance':
        imagePlaneNum = 3
    # Make a dataframe of a single object so that we can plot the stamps for only this object
    singleObject = objectList[objectList['name']==name]
    singleObject.reset_index(inplace=True)

    # Find the number of subplots to make. Add one for the coadd.
    numPlots = len(singleObject.index)+1
    # Compute number of rows for the plot
    numRows = numPlots // numCols
    # Add a row if numCols doesn't divide evenly into numPlots
    if (numPlots % numCols):
        numRows+=1
    # Add a row if numRows=1. Avoids an error caused by ax being 1D.
    if (numRows==1):
        numRows+=1
    # Generate the subplots, setting the size with figsize
    fig,ax = plt.subplots(nrows=numRows,ncols=numCols,
                          figsize=[3*numCols,3.5*numRows])
    objectMag = np.max(singleObject['v_mag'])
    # Find object velocity in pixels/day and the object angle in radians
    # total_motion is in arcsec/hr. DECam has .26arcsec/pixel ccd's. 24 hr/day.
    # Load initial and final object positions and calculate the trajectory angle
    findMotion = singleObject.query('ccd=={}'.format(singleObject['ccd'].values[0]))
    xi = np.array([findMotion['x_pixel'].values[0],
                   findMotion['y_pixel'].values[0]])
    xf = np.array([findMotion['x_pixel'].values[-1],
                   findMotion['y_pixel'].values[-1]])
    dx = xf-xi
    objectAngle = np.arctan2(dx[1],dx[0])
    dr = np.linalg.norm(dx)
    visitId=np.array(findMotion['visit_id'])
    visitKey,times=np.loadtxt(timeFile,unpack=True)
    dt=times[visitKey==visitId[-1]]-times[visitKey==visitId[0]]
    dt=dt[0]
    objectVel = dr/dt
    xVel = dx[0]/dt
    yVel = dx[1]/dt
    
    if objectAngle<0:
        objectAngle += 2*np.pi
    figTitle = '{}: {} image\nv_mag={}, velocity=[{:.2f},{:.2f}]={:.2f} px/day, angle={:.2f}'
    fig.suptitle(figTitle.format(name,imagePlane,objectMag,xVel,yVel,objectVel,objectAngle),
                 fontsize=16)
    # Turn off all axes. They will be turned back on for proper plots.
    for row in ax:
        for column in row:
            column.axis('off')

    stampEdge = (stampSize[0]-1)/2
    size = stampSize[0]
    x = np.linspace(-stampEdge, stampEdge, size)
    y = np.linspace(-stampEdge, stampEdge, size)
    sigma_x = 1.4
    sigma_y = 1.4

    x, y = np.meshgrid(x, y)
    gaussian_kernel = (1/(2*np.pi*sigma_x*sigma_y) 
        * np.exp(-(x**2/(2*sigma_x**2) + y**2/(2*sigma_y**2))))
    sum_pipi = np.sum(gaussian_kernel**2)
    noise_kernel = np.zeros(stampSize)
    x_mask = np.logical_or(x>5, x<-5)
    y_mask = np.logical_or(y>5, y<-5)
    mask = np.logical_or(x_mask,y_mask)
    noise_kernel[mask] = 1

    # Set the axis indexes. These are needed to plot the stamp in the correct subplot
    axi=0
    axj=1
    for i,row in singleObject.iterrows():
        # Get the Lori Allen visit id from the single object list
        visit_id = row['visit_id']
        ccd = row['ccd']
        # Get the x and y values from the first object in the cut list. Round to an integer.
        objectLoc = np.round([row['x_pixel'],row['y_pixel']])
        # Open up the fits file of interest using the pre-defined filepath string
        hdul = fits.open(os.path.join(imagePath,'{:02}/{}.fits'.format(ccd,visit_id)))

        # Generate the minimum and maximum pixel values for the stamps using stampSize
        xmin = int(objectLoc[0]-(stampSize[0]-1)/2+0.5)-1
        xmax = int(objectLoc[0]+(stampSize[0]-1)/2+0.5)
        ymin = int(objectLoc[1]-(stampSize[1]-1)/2+0.5)-1
        ymax = int(objectLoc[1]+(stampSize[1]-1)/2+0.5)

        im_dims = np.shape(hdul[imagePlaneNum].data)
        # Plot the stamp
        stampData = hdul[imagePlaneNum].data[ymin:ymax,xmin:xmax]
        #print(np.isnan(stampData))
        stampData[np.isnan(stampData)] = 0.0
        if i==0:
            coaddData=stampData
        else:
            coaddData+=stampData
        im = ax[axi,axj].imshow(stampData,cmap=plt.cm.bone)
        signal = np.sum(stampData*gaussian_kernel)
        noise = np.var(stampData*noise_kernel)
        SNR = signal/np.sqrt(noise*sum_pipi)
        ax[axi,axj].set_title(
            'ccd={} | visit={}\nSNR={:.2f}'.format(ccd,visit_id,SNR))
        ax[axi,axj].axis('on')
        # Compute the axis indexes for the next iteration
        if axj<numCols-1:
            axj+=1
        else:
            axj=0
            axi+=1
    im = ax[0,0].imshow(coaddData,cmap=plt.cm.bone)
    signal = np.sum(coaddData*gaussian_kernel)
    noise = np.var(coaddData*noise_kernel)
    SNR = signal/np.sqrt(noise*sum_pipi)
    ax[0,0].axis('on')
    _=ax[0,0].set_title('Coadd | SNR={:.2f}'.format(SNR))
